<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="pt">
<head>
<!-- Generated by javadoc (1.8.0_171) on Tue Jun 12 20:17:03 WEST 2018 -->
<title>TCDExample</title>
<meta name="date" content="2018-06-12">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="TCDExample";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../engine/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../engine/Tag.html" title="class in engine"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../engine/User.html" title="class in engine"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?engine/TCDExample.html" target="_top">Frames</a></li>
<li><a href="TCDExample.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">engine</div>
<h2 title="Class TCDExample" class="title">Class TCDExample</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>engine.TCDExample</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">TCDExample</span>
extends java.lang.Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#TCDExample--">TCDExample</a></span>()</code>
<div class="block">Construtor por omissao de TCDExmaple.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#betterAnswer-long-">betterAnswer</a></span>(long&nbsp;id)</code>
<div class="block">Query de procura da melhor resposta da pergunta com id passado por argumento.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#bothParticipated-int-long-long-">bothParticipated</a></span>(int&nbsp;N,
                long&nbsp;id1,
                long&nbsp;id2)</code>
<div class="block">Query de procura de posts em que dois utilizadores participaram.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#clear--">clear</a></span>()</code>
<div class="block">Metodo de limpeza das estruturas.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#containsWord-int-java.lang.String-">containsWord</a></span>(int&nbsp;N,
            java.lang.String&nbsp;word)</code>
<div class="block">query de procura de N perguntas que conteem uma determinada palavra no seu titulo.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;any&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#getUserInfo-long-">getUserInfo</a></span>(long&nbsp;id)</code>
<div class="block">Query de procura de dados relativos a um user.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;any&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#infoFromPost-long-">infoFromPost</a></span>(long&nbsp;id)</code>
<div class="block">Query de obtençao de informação relativa a um post (seja pergunta ou resposta).</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#load-java.lang.String-">load</a></span>(java.lang.String&nbsp;dumpPath)</code>
<div class="block">Método responsável pelo carregamento dos dados para as estruturas.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#mostAnsweredQuestions-int-java.time.LocalDate-java.time.LocalDate-">mostAnsweredQuestions</a></span>(int&nbsp;N,
                     java.time.LocalDate&nbsp;begin,
                     java.time.LocalDate&nbsp;end)</code>
<div class="block">Query de procura das N perguntas mais respondidas.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#mostVotedAnswers-int-java.time.LocalDate-java.time.LocalDate-">mostVotedAnswers</a></span>(int&nbsp;N,
                java.time.LocalDate&nbsp;begin,
                java.time.LocalDate&nbsp;end)</code>
<div class="block">Query de procura das N respostas mais votadas.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#questionsWithTag-java.lang.String-java.time.LocalDate-java.time.LocalDate-">questionsWithTag</a></span>(java.lang.String&nbsp;tag,
                java.time.LocalDate&nbsp;begin,
                java.time.LocalDate&nbsp;end)</code>
<div class="block">Query de procura de perguntas que possuem uma determinada tag e se encontram dentro de
 um determinado intervalo de tempo.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#topMostActive-int-">topMostActive</a></span>(int&nbsp;N)</code>
<div class="block">Query de procura dos N utilizadores mais ativos.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;any&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../engine/TCDExample.html#totalPosts-java.time.LocalDate-java.time.LocalDate-">totalPosts</a></span>(java.time.LocalDate&nbsp;begin,
          java.time.LocalDate&nbsp;end)</code>
<div class="block">Query de contagem do numero total de posts entre um determinado intervalo de tempo.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="TCDExample--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>TCDExample</h4>
<pre>public&nbsp;TCDExample()</pre>
<div class="block">Construtor por omissao de TCDExmaple.
 <p>
 Inicializa todos os parametros de TCDExample atravez dos seus construtores por omissao.
 <p>
 users e inicializado com o metodo CatUsers() de CatUsers.java.
 <p>
 perguntas e inicializado com o metodo CatPerguntas() de CatPerguntas.java.
 <p>
 respostas e inicializado com o metodo CatRespostas() de CatRespostas.java.
 <p>
 tags e inicializado com o metodo CatTags() de CatTags.java</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/CatUsers.html#CatUsers--"><code>CatUsers.CatUsers()</code></a>, 
<a href="../engine/CatPerguntas.html#CatPerguntas--"><code>CatPerguntas.CatPerguntas()</code></a>, 
<a href="../engine/CatRespostas.html#CatRespostas--"><code>CatRespostas.CatRespostas()</code></a>, 
<a href="../engine/CatTags.html#CatTags--"><code>CatTags.CatTags()</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="load-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>load</h4>
<pre>public&nbsp;void&nbsp;load(java.lang.String&nbsp;dumpPath)</pre>
<div class="block">Método responsável pelo carregamento dos dados para as estruturas.
 <p>
 parseUsers(String,CatUsers) carrega os dados correspondentes aos sers para users
  <a href="../engine/Parser.html#parseUsers-java.lang.String-engine.CatUsers-"><code>Parser.parseUsers(java.lang.String, engine.CatUsers)</code></a>
 <p>
 parsePosts(String,CatUsers,CatPerguntas,CatRespostas) carrega dados relativos a Users,
  Perguntas e Respostas <a href="../engine/Parser.html#parsePosts-java.lang.String-engine.CatUsers-engine.CatPerguntas-engine.CatRespostas-"><code>Parser.parsePosts(java.lang.String, engine.CatUsers, engine.CatPerguntas, engine.CatRespostas)</code></a>
 <p>
 parseTags(String,CatTags) carrega dados relativas as tags <a href="../engine/Parser.html#parseTags-java.lang.String-engine.CatTags-"><code>Parser.parseTags(java.lang.String, engine.CatTags)</code></a></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/Parser.html" title="class in engine"><code>Parser</code></a></dd>
</dl>
</li>
</ul>
<a name="infoFromPost-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>infoFromPost</h4>
<pre>public&nbsp;&lt;any&gt;&nbsp;infoFromPost(long&nbsp;id)</pre>
<div class="block">Query de obtençao de informação relativa a um post (seja pergunta ou resposta).
 <p>
 Acede as estruturas de forma a procurar um post com id igual a um long passado por argumento
 e guarda essa informacao num Par de Strings (Classe Pair).
 <p>
 Este método esta dividido em duas partes mutuamente exclusivas (if else)
 <p>
 A primeira parte e responsavel por detetar se o post que pretendemos procurar e uma pregunta:
 <code>if(this.perguntas.getCatPerg().contaisKey(id))</code> obtem o HashMap catPerg de perguntas e
 acede-o para confirmar se existe alguma entrada com id igual ao long passado por argumento.
 Caso esse teste seja true guarda a informacao relativa ao post:
 <code>p = this.perguntas.getCatPerg().get(id)</code> acede a catPerg de perguntas e guarda a Pergunta
 com chave correspondente a id.
 <code>u = this.users.getCatUsers().get(p.getOwnerIDp())</code> acede ao HashMap de users e procura pelo
 user que publicou a pergunta p, o id da pergunta e obtida por getOwnerIDp que e passado ao metodo get
 aplicado a catUsers de users.
 por fim a informacao relativa ao titulo da pergunta e ao nome do user e armazenada em duas strings.
 <p>
 A segunda parte efetua codigo semelhante a primeira contudo verifica se o post e uma resposta
 e caso seja, guarda a informacao relativa a pergunta que originou essa resposta e ao user que publicou
 a pergunta.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - id do post a ser procurado</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>um par <code>Pair</code> de strings contedo o titulo de uma pergunta e o nome do user
 que a publicou.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/CatPerguntas.html#getCatPerg--"><code>CatPerguntas.getCatPerg()</code></a>, 
<a href="../engine/CatUsers.html#getCatUsers--"><code>CatUsers.getCatUsers()</code></a>, 
<a href="../engine/Pergunta.html#getOwnerIDp--"><code>Pergunta.getOwnerIDp()</code></a>, 
<a href="../engine/Pergunta.html#getTitle--"><code>Pergunta.getTitle()</code></a>, 
<a href="../engine/User.html#getName--"><code>User.getName()</code></a>, 
<a href="../engine/CatRespostas.html#getCatResp--"><code>CatRespostas.getCatResp()</code></a>, 
<code>HashMap</code></dd>
</dl>
</li>
</ul>
<a name="topMostActive-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topMostActive</h4>
<pre>public&nbsp;java.util.List&lt;java.lang.Long&gt;&nbsp;topMostActive(int&nbsp;N)</pre>
<div class="block">Query de procura dos N utilizadores mais ativos.
 <p>
 Armazena numa List os N utilizadores mais ativos de entre os presentes em Users.
 <p>
 De modo a procurar todos os utilizadores a estrutura e precorrida atravez do uso de uma stream
 de eventos (de modo a aumentar a eficiencia).
 <p>
 <code>Comparator comparador = new ComparadorNrPosts()</code> serve de lei de comparacao
 entre users tendo como parametro de comparacao o numero de contribuicoes.
 <p>
 list = ... a lista de resultados i sera igual ao resultado de aplicar uma serie de operacoes
 em sequencia alimentadas por uma stream de eventos.
 <p>
 <code>this.users.getCatUsers()</code> obtem o HashMap catUsers de users.
 <p>
 <code>entrySet()</code> "transforma" o  HashMap num set itravel.
 <p>
 <code>stream()</code> cria uma stream de eventos do entrySet alimentando os metodos seguintes
 com os eventos de entrySet em sequencia sem dependerem uns dos outros, dai que a medida que novas
 entadas do set sao aliemntadas a stream as anteriores ja estao a ser processadas pelos diversos metods.
 <p>
 <code>sorted(comparador)</code> utilizando o comparador como regra de comparacao de users, este metodo
 ordena os eventos que lhe sao alimentados.
 <p>
 <code>limit(N)</code> introduz um limite maximo de eventos que se pode ter, isto e, apenas aproveita os
 N primeiros eventos (que sao os N maiores gracas a sorted)
 <p>
 <code>map(e->e.getValue().getUserID())</code> para cada entrada (chave valor) este metodo aproveita
 apenas o UserID de cada user que recebe.
 <p>
 <code>collect(Collectors.toCollection(ArrayList :: new))</code> armazena os eventos que recebe de novo.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>N</code> - numero de IDs que pretendemos obter.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a lista dos ids dos users com mais contribuicoes ordenada.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/ComparadorNrPosts.html" title="class in engine"><code>ComparadorNrPosts</code></a>, 
<code>ArrayList</code>, 
<a href="../engine/User.html#getUserID--"><code>User.getUserID()</code></a></dd>
</dl>
</li>
</ul>
<a name="totalPosts-java.time.LocalDate-java.time.LocalDate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>totalPosts</h4>
<pre>public&nbsp;&lt;any&gt;&nbsp;totalPosts(java.time.LocalDate&nbsp;begin,
                        java.time.LocalDate&nbsp;end)</pre>
<div class="block">Query de contagem do numero total de posts entre um determinado intervalo de tempo.
 <p>
 este metodo esta dividido em duas partes:
 <p>
 A primeira parte visa a precorres as perguntas atravez de um foreach e incrementa uma
 vairavel interia perg cada vez que encontra uma pergunta dentro do intervalo.
 <code>if(p.getPergDate().compareTo(begin) && p.getPergDate().compareTo(end)</code>
 Esta porçao de codigo acede a pergunta p (cada pergunta gracas a ao for each) obtem a data
 da pertunta e compara respectivamente entre o begin e o end.
 <p>
 A segunda parte efetua codigo semelhante a primeira com a diferenca de iterar sobre as respostas
 e incrementar uma variavel inteira correspondente as respostas.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>begin</code> - Data inicial do intervalo</dd>
<dd><code>end</code> - Data filan do intervalo</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Par de Longs correspondentes a contagem de perguntas e respostas.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/Pergunta.html#getPergDate--"><code>Pergunta.getPergDate()</code></a>, 
<code>LocalDate</code></dd>
</dl>
</li>
</ul>
<a name="questionsWithTag-java.lang.String-java.time.LocalDate-java.time.LocalDate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>questionsWithTag</h4>
<pre>public&nbsp;java.util.List&lt;java.lang.Long&gt;&nbsp;questionsWithTag(java.lang.String&nbsp;tag,
                                                       java.time.LocalDate&nbsp;begin,
                                                       java.time.LocalDate&nbsp;end)</pre>
<div class="block">Query de procura de perguntas que possuem uma determinada tag e se encontram dentro de
 um determinado intervalo de tempo.
 <p>
 Neste metodo e utilizado um Comparator comparador que serve como regra de ordenacao das perguntas.
 <p>
 <code>this.perguntas.getCatPerg().entrySet().stream()</code> acede a catPerg de perguntas geta um
 set iteravel de catPerg e inicia uma stream de eventos deste set.
 <p>
 Filter(perdicado) cada entrada da stream apenas segue para os proximos metodos se passar
 no teste Perdicado.
 <p>
 <code>e.getValue().getTags().contains(tag)</code> porcao do perdicado que testa se uma string tag esta
 nas tags da pergunta correspondente ao evento e (cada evento da stream)
 <p>
 <code>e.getValue().getPergDate().comapreTo(begin)</code> porcao do perdicado que testa se uma pergunta
 foi publicada depois de uma determinada data begin.
 <p>
 <code> <p>e.getValue()getPertDate().compareTo(end)</code> porcao do perdicado que testa se uma 
 pergunta foi publicada antes de uma denterminada data end.
 <p>
 apenas eventos que passam em todas as tres porcoes do perdicado podem prosseguir para os proximos
 metodos.
 <p>
 <code>sorted(comparador)</code> ordena os eventos segundo a regra defenida em comparador
 <a href="../engine/ComparadorDatesP.html" title="class in engine"><code>ComparadorDatesP</code></a>
 <p>
 <code>map(e.getValue().getPergID)</code> para cada evento (Pergunta) aproveita apenas o seu id.
 <p>
 <code>collect(collectors.toCollection(ArrayList :: new))</code> armazena os eventos (ja ordenadados)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tag</code> - String correspondente a tag a procurar</dd>
<dd><code>begin</code> - data inicial do intervalo de tempo</dd>
<dd><code>end</code> - data final do intervalo de tempo</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>lista ordenada dos ids das perguntas que possuem a tag e foram publicadas dentro do
 intervalo de tempo begin end.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/CatPerguntas.html#getCatPerg--"><code>CatPerguntas.getCatPerg()</code></a>, 
<a href="../engine/ComparadorDatesP.html" title="class in engine"><code>ComparadorDatesP</code></a></dd>
</dl>
</li>
</ul>
<a name="getUserInfo-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUserInfo</h4>
<pre>public&nbsp;&lt;any&gt;&nbsp;getUserInfo(long&nbsp;id)</pre>
<div class="block">Query de procura de dados relativos a um user.
 <p>
 Dados do user correspondem ao seu bio e aos 10 primeiros posts por ele efectuados.
 <p>
 Este metodo esta dividido em 5 partes.
 <p>
 Primeira parte cria os 3 comparadores que servirao como regra de ordenacao entre
 perguntas, respostas e datas.
 <p>
 Segunda parte obtem o bio relativo ao user com id passado por argumento.
 <p>
 Terceira parte precorre a estrutura de perguntas com uma stream (this.perguntas.getCatPerg().
 entrySet().stream()), filtra as perguntas que possuem userID igual ao id de argumento (filter
 (e.getValue().getOwnerIDp()==id)), ordena os eventos segundo a regra comparadorP, (sorted(comparadorp)),
 retira os 10 primeiros que gracas a ordenacao correspondem as 10 menores datas (limit(10)),
 dos eventos obtem apenas as perguntas (map(e.getValue())), arazenas as perguntas
 (collect(Collectors.toCollection(ArrayList :: new))).
 <p>
 A quarta parte realiza uma tarefa semelhante a terceira mas precorrendo as respostas.
 <p>
 A quinta parte introduz os ids das 10 perguntas e 10 respostas obtidas nas partes 3 e 4 todas na mesma
 estrutura, atravez de uma stream de eventos ordena-as por data segundo a regra comparadorL e obtem os
 ids dos 10 primeiros elementos da estrutura resultado, obtendo por isso os ids dos 10 primeiros
 posts efectuados por esse user (sejam perguntas ou respostas).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - id do user a obter informacao.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>um par string List correspondete ao bio do utilizador e a lista ordenada dos 10 primeiros
 posts efectuados por esse utilizador.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/ComparadorDatesP.html" title="class in engine"><code>ComparadorDatesP</code></a>, 
<a href="../engine/ComparadorDatesR.html" title="class in engine"><code>ComparadorDatesR</code></a>, 
<a href="../engine/ComparadorDatesL.html" title="class in engine"><code>ComparadorDatesL</code></a>, 
<a href="../engine/User.html#getBio--"><code>User.getBio()</code></a></dd>
</dl>
</li>
</ul>
<a name="mostVotedAnswers-int-java.time.LocalDate-java.time.LocalDate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mostVotedAnswers</h4>
<pre>public&nbsp;java.util.List&lt;java.lang.Long&gt;&nbsp;mostVotedAnswers(int&nbsp;N,
                                                       java.time.LocalDate&nbsp;begin,
                                                       java.time.LocalDate&nbsp;end)</pre>
<div class="block">Query de procura das N respostas mais votadas.
 <p>
 Atravez do uso de uma stream sobre as respostas esta query obtem as N respostas com melhor score
 obtidas entre um intevalo de tempo. Esta operacao possui os seguinte passos:
 <p>
 <code>this.respostas.getCatResp().entrySet().stream()</code> acede a catResp de respostas, cria um
 set iteravel desse HashMap e gera uma stream de eventos de tais respostas.
 <p>
 <code>filter(perdicado)</code> filtra os eventos que recebe deixando passar apenas os eventos que
 passam no perdicado.
 <p>
 <code>e.getValue().getRespDate().compareTo(begin)</code> acede a data do evento e compara com begin
 devolvendo true caso este tenha sido publicado apos a data begin (ou igual).
 <p>
 <code>e.getValue().getRespDate().compareTo(end)</code> acede a data do evento e compara com end 
 devolvendo true caso este tenha sido publicado antes de end (ou igual).
 <p>
 <code>sorted(comparador)</code> ordena os eventos segundo a regra definida em <a href="../engine/ComparadorScore.html" title="class in engine"><code>ComparadorScore</code></a>
 <p>
 <code>limit(N)</code> obtem os 10 primeiros eventos (ja ordenados).
 <p>
 <code>map(e.getValue().getRespID())</code> obtem o id da resposta (value) do evento.
 <p>
 <code>collect(Collectors.toCollection(ArrayList :: new))</code> armazena os eventos de novo.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>N</code> - numero de respostas a obter.</dd>
<dd><code>begin</code> - data inicial do intervalo.</dd>
<dd><code>end</code> - data final do intervalo.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>lista ordenada por score das respostas mais votadas.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/CatRespostas.html#getCatResp--"><code>CatRespostas.getCatResp()</code></a>, 
<a href="../engine/Resposta.html#getRespDate--"><code>Resposta.getRespDate()</code></a>, 
<a href="../engine/Resposta.html#getRespID--"><code>Resposta.getRespID()</code></a></dd>
</dl>
</li>
</ul>
<a name="mostAnsweredQuestions-int-java.time.LocalDate-java.time.LocalDate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mostAnsweredQuestions</h4>
<pre>public&nbsp;java.util.List&lt;java.lang.Long&gt;&nbsp;mostAnsweredQuestions(int&nbsp;N,
                                                            java.time.LocalDate&nbsp;begin,
                                                            java.time.LocalDate&nbsp;end)</pre>
<div class="block">Query de procura das N perguntas mais respondidas.
 <p>
 Atravéz de um mecanismo de java stream bastante semelhante ao utilizado em querys antreiores,
 as Perguntas sao precorridas atravez de uma stream de eventos, estas sao filtradas a partir da sua
 data (data pertence ao intervalo) passando apenas os eventos cujo perdicado retorna true, os eventos
 restantes sao ordenados segundo a regra definida em <a href="../engine/ComparadorNrResps.html" title="class in engine"><code>ComparadorNrResps</code></a>, os N primeiros sao
 obtidos, sao retirados os ids das Perguntas dos eventos (id dos values) e por final os ids sao
 armazenados.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>N</code> - numero de perguntas a obter.</dd>
<dd><code>begin</code> - data inicial do intervalo.</dd>
<dd><code>end</code> - data final do intervalo.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Lista ordenada dos ids das perguntas mais respondidas.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/ComparadorNrResps.html" title="class in engine"><code>ComparadorNrResps</code></a>, 
<a href="../engine/CatPerguntas.html#getCatPerg--"><code>CatPerguntas.getCatPerg()</code></a>, 
<a href="../engine/Pergunta.html#getPergDate--"><code>Pergunta.getPergDate()</code></a>, 
<a href="../engine/Pergunta.html#getPergID--"><code>Pergunta.getPergID()</code></a></dd>
</dl>
</li>
</ul>
<a name="containsWord-int-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>containsWord</h4>
<pre>public&nbsp;java.util.List&lt;java.lang.Long&gt;&nbsp;containsWord(int&nbsp;N,
                                                   java.lang.String&nbsp;word)</pre>
<div class="block">query de procura de N perguntas que conteem uma determinada palavra no seu titulo.
 <p>
 Utiliza uma estrategia de java stream semelhante a outras querys.
 <p>
 a filtragem tem como perdicado a existencia da palavra word no titulo.
 <p>
 A ordenacao e feita segundo a regra comparadorDatesP
 <p>
 limit(N) obtem-se apenas os n primeiros.
 <p>
 O map retira o id da pergunta
 <p>
 collect armazena os eventos.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>N</code> - numero de perguntas a obter.</dd>
<dd><code>word</code> - palavra a procurar.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>lista ordenada por datas das N primeiras perguntas que conteem a palavra N.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/ComparadorDatesP.html" title="class in engine"><code>ComparadorDatesP</code></a>, 
<a href="../engine/CatPerguntas.html#getCatPerg--"><code>CatPerguntas.getCatPerg()</code></a>, 
<a href="../engine/Pergunta.html#getTitle--"><code>Pergunta.getTitle()</code></a>, 
<a href="../engine/Pergunta.html#getPergID--"><code>Pergunta.getPergID()</code></a></dd>
</dl>
</li>
</ul>
<a name="bothParticipated-int-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bothParticipated</h4>
<pre>public&nbsp;java.util.List&lt;java.lang.Long&gt;&nbsp;bothParticipated(int&nbsp;N,
                                                       long&nbsp;id1,
                                                       long&nbsp;id2)</pre>
<div class="block">Query de procura de posts em que dois utilizadores participaram.
 <p>
 Este metodo esta dividido me 7 partes.
 <p>
 Primeira parte coleciona as perguntas pertencentes ao user 1 atravez de uma estrategia de java stream
 semelhante ao efectuado em metodos anteriores. O perdicado do filter e a comparacao do ownerUserID
 da pergunta com o id1 passado por argumento.
 <p>
 map obtem a pergunta de dentro do evento.
 <p>
 collect armazena as perguntas em persUser1.
 <p>
 A segunda parte efectua uma tarefa semelhante a primeira porem tendo em consideracao o user2 em vez
 do user1 armazenando as suas perguntas em PergsUser2.
 <p>
 A terceira Parte inicializa tres estruturas auxiliares. Um map de perguntas e dois sets de respostas
 set1 e set2.
 <p>
 A quarta Parte trata do caso de user1 aparecer na pergunta e user2 na resposta.
 Utiliza um foreach sobre as perguntas do user1 (pergsUser1) e para cada uma precorre as suas respostas
 a procura de respostas cujo owner e o user2 (mais um foreach sobre o set1 que e correspondido ao
 set de respostas da pergunta). Assim que a primeira resposta e encontrada a pergunta e inserida no map.
 <p>
 A quita parte trata do caso de user2 aparcer na pergunta e user1 na resposta.
 Efetua uma tarefa igual a parte 4 mas iterando sobre as perguntas do user 2 a procura de respostas
 do user1. 
 <p>
 A sexta parte trata do caso de ambos os users surgirem em respostas.
 Todas as pergutnas sao iteradas segundo um forach sobre o HashMap de perguntas. Para cada pergunta
 e precorrido o seu set de respostas a procura de ambos os users atravez de um foreach sobre o set3
 correspondete ao set de respostas da pergunta.
 Uma flag inteira e utilizada para se saber quantos dos 2 users ja se encotrou.
 Caso a flag seja igual a 2 significa que ambos os users ja foram encontrados e que o id da pergunta ja
 foi armazemado pelo que se pode prosseguir para a proxima pergunta.
 Caso a flag esteja a 1 entao significa que um dos users ja foi encontrado pelo que e nessessario
 verificar se a resposta atual foi efectuada por um dos users, caso seja verdade a pergunta e armazenada
 no map e a flag e incrementada.
 Caso a flag esteja a 0 e caso a resposta atual possua owner igual a um dos users entao a flag
 e incrementada.
 Esta sequencia de operacoes introduz no map as perguntas que ambos os users surgem como resposta.
 <p>
 A setima parte consiste em precorrer o map de respostas atravez de uma stream de eventos a semelhanca
 de metodos anteriores.
 Os eventos sao ordenados segundo a regra definida em <a href="../engine/ComparadorDatesP.html" title="class in engine"><code>ComparadorDatesP</code></a>, sao obtidos os N
 primeiros elementos, de cada elemento obtem-se o seu id que sao por fim armazenados ja ordenados
 obtendo por isso a lista dos ids dos posts em que ambos os utilizadores participaram.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>N</code> - numero de posts a obter.</dd>
<dd><code>id1</code> - id do user 1</dd>
<dd><code>id2</code> - id do user 2</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>lista ordenada por data dos ids das perguntas em que ambos os users participaram (no post).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/CatPerguntas.html#getCatPerg--"><code>CatPerguntas.getCatPerg()</code></a>, 
<a href="../engine/Pergunta.html#getOwnerIDp--"><code>Pergunta.getOwnerIDp()</code></a>, 
<a href="../engine/Resposta.html#getOwnerIDr--"><code>Resposta.getOwnerIDr()</code></a>, 
<a href="../engine/Pergunta.html#getPergID--"><code>Pergunta.getPergID()</code></a>, 
<a href="../engine/Pergunta.html#getRespostas--"><code>Pergunta.getRespostas()</code></a>, 
<a href="../engine/ComparadorDatesP.html" title="class in engine"><code>ComparadorDatesP</code></a></dd>
</dl>
</li>
</ul>
<a name="betterAnswer-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>betterAnswer</h4>
<pre>public&nbsp;long&nbsp;betterAnswer(long&nbsp;id)</pre>
<div class="block">Query de procura da melhor resposta da pergunta com id passado por argumento.
 <p>
 Caso o id passado nao exista no HashMap de perguntas este metodo retorna -1.
 <p>
 A procura sera efectuada sobre o set de respostas da pergunta cujo id e passado por argumento.
 <p>
 Com o uso de um for each para cada resposta deste set e comparado o seu rate com o rate da melhor
 resposta encontrada ate agora, caso esta resposta seja melhor entao o seu id e rate sao guardados
 como sendo a nova melhor resposta.
 <p>
 O resultado e o id da melhor resposta encontrada.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - id da pergunta alvo.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>id da resposta da pergunta com maior rate.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/CatPerguntas.html#getCatPerg--"><code>CatPerguntas.getCatPerg()</code></a>, 
<a href="../engine/Pergunta.html#getRespostas--"><code>Pergunta.getRespostas()</code></a>, 
<a href="../engine/Resposta.html#getRate--"><code>Resposta.getRate()</code></a>, 
<a href="../engine/Resposta.html#getRespID--"><code>Resposta.getRespID()</code></a></dd>
</dl>
</li>
</ul>
<a name="clear--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>clear</h4>
<pre>public&nbsp;void&nbsp;clear()</pre>
<div class="block">Metodo de limpeza das estruturas.
 <p>
 Utiliza os metodos clear de cada uma das estruturas catUsers, catPerg, CatResp e catTags para efectuar
 a limpeza das mesmas.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../engine/CatUsers.html#clearCatUsers--"><code>CatUsers.clearCatUsers()</code></a>, 
<a href="../engine/CatPerguntas.html#clearCatPerg--"><code>CatPerguntas.clearCatPerg()</code></a>, 
<a href="../engine/CatRespostas.html#clearCatResp--"><code>CatRespostas.clearCatResp()</code></a>, 
<a href="../engine/CatTags.html#clearCatTags--"><code>CatTags.clearCatTags()</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../engine/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../engine/Tag.html" title="class in engine"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../engine/User.html" title="class in engine"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?engine/TCDExample.html" target="_top">Frames</a></li>
<li><a href="TCDExample.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
